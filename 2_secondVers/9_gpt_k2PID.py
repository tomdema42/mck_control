# -*- coding: utf-8 -*-
"""
Created on Mon Jan 12 12:19:10 2026

@author: demaria
"""

import numpy as np
from scipy.integrate import solve_ivp
from scipy.optimize import minimize
from _auxFunc import load_params, make_forcing

def simulate_from_file(param_file, pid, gamma=1.0):
    """
    k2(t) is generated by a PID that tries to force x2(t) to track an anti-phase reference:
        x2_ref = -gamma * x1

    PID error:
        e     = x2_ref - x2 = -gamma*x1 - x2
        e_dot = d/dt(e)     = -gamma*x1d - x2d
        z     = ∫ e dt  (extra ODE state)

    Control law:
        k2 = clip(k2_base + Kp*e + Ki*z + Kd*e_dot, k2_min, k2_max)
    """

    p = load_params(param_file)

    m1, m2 = p["m1"], p["m2"]
    k1 = p["k1"]
    c1, c2 = p["c1"], p["c2"]
    cd, kc = p["cd"], p["kc"]

    # Optional params (safe defaults)
    k2_base = p.get("k2_nom", 0.0)
    k2_min = p.get("k2_min", 0.0)
    k2_max = p.get("k2_max", 1e9)

    # Optional anti-windup (integrator clamp)
    z_min = p.get("pid_int_min", -1e9)
    z_max = p.get("pid_int_max", 1e9)

    Kp = float(pid.get("Kp", 0.0))
    Ki = float(pid.get("Ki", 0.0))
    Kd = float(pid.get("Kd", 0.0))

    F_ext = make_forcing(p)

    # Add integral state z0 (default 0)
    y0 = (p["x1_0"], p["x1d_0"], p["x2_0"], p["x2d_0"], p.get("pid_int_0", 0.0))
    t_eval = np.linspace(p["t0"], p["t_end"], int(p["n_points"]))

    def rhs(t, y):
        x1, x1d, x2, x2d, z = y

        # PID error to enforce anti-phase tracking of x2
        e = -gamma * x1 - x2
        e_dot = -gamma * x1d - x2d

        # Raw (unsaturated) k2 command
        k2_cmd = k2_base + Kp * e + Ki * z + Kd * e_dot
        k2 = float(np.clip(k2_cmd, k2_min, k2_max))

        # Simple anti-windup: stop integrating if saturated and integration would push further into saturation
        z_dot = e
        if k2 >= k2_max and e > 0:
            z_dot = 0.0
        if k2 <= k2_min and e < 0:
            z_dot = 0.0

        # Dynamics (same as yours, but with k2(t))
        x1dd = (-k1 * x1 - c1 * x1d + cd * (x2d - x1d) + kc * (x2 - x1) + F_ext(t)) / m1
        x2dd = (-k2 * x2 - c2 * x2d - cd * (x2d - x1d) - kc * (x2 - x1)) / m2

        # Clamp integrator state softly inside bounds via dynamics
        if z <= z_min and z_dot < 0:
            z_dot = 0.0
        if z >= z_max and z_dot > 0:
            z_dot = 0.0

        return [x1d, x1dd, x2d, x2dd, z_dot]

    sol = solve_ivp(
        rhs,
        (p["t0"], p["t_end"]),
        y0,
        t_eval=t_eval,
        rtol=1e-8,
        atol=1e-8,
    )

    if not sol.success:
        raise RuntimeError(sol.message)

    # Reconstruct k2(t) from the solution
    x1 = sol.y[0]
    x1d = sol.y[1]
    x2 = sol.y[2]
    x2d = sol.y[3]
    z = sol.y[4]

    e = -gamma * x1 - x2
    e_dot = -gamma * x1d - x2d
    k2_cmd = k2_base + Kp * e + Ki * z + Kd * e_dot
    k2_t = np.clip(k2_cmd, k2_min, k2_max)

    return sol.t, sol.y, k2_t


def cost_pid(gains, param_file, lambda_k2=0.0, gamma=1.0):
    """
    gains = [Kp, Ki, Kd]
    Objective:
        J = ∫ x1(t)^2 dt + lambda_k2 * ∫ (k2(t) - k2_base)^2 dt
    """
    Kp, Ki, Kd = gains

    # basic sanity (optional)
    if not np.isfinite(Kp + Ki + Kd):
        return np.inf

    p = load_params(param_file)
    k2_base = p.get("k2_nom", 0.0)

    pid = {"Kp": Kp, "Ki": Ki, "Kd": Kd}

    try:
        t, y, k2_t = simulate_from_file(param_file, pid, gamma=gamma)
        x1 = y[0]

        J_x1 = np.trapezoid(x1**2, t)
        J_k2 = np.trapezoid((k2_t - k2_base) ** 2, t)

        J = J_x1 + float(lambda_k2) * J_k2
        if not np.isfinite(J):
            return np.inf
        return J

    except Exception:
        return np.inf


# Example: optimize PID gains (you can change bounds / initial guess)
def optimize_pid(param_file, lambda_k2=0.0, gamma=1.0):
    x0 = np.array([50.0, 0.0, 0.0])  # [Kp, Ki, Kd]
    bounds = [(-1e6, 1e6), (-1e6, 1e6), (-1e6, 1e6)]

    res = minimize(
        lambda g: cost_pid(g, param_file, lambda_k2=lambda_k2, gamma=gamma),
        x0,
        method="L-BFGS-B",
        bounds=bounds,
    )

    best_pid = {"Kp": res.x[0], "Ki": res.x[1], "Kd": res.x[2]}
    return best_pid, res
if __name__ == "__main__":
    import matplotlib.pyplot as plt

    param_file = "params.txt"  # <-- change this
    lambda_k2 = 1e6
    gamma = 0.0

    best_pid, res = optimize_pid(param_file, lambda_k2=lambda_k2, gamma=gamma)

    print("Best PID:", best_pid)
    print("Objective:", res.fun)

    t, y, k2_t = simulate_from_file(param_file, best_pid, gamma=gamma)
    x1, x1d, x2, x2d, z = y

    plt.figure()
    plt.plot(t, x1, label="x1")
    plt.plot(t, x2, label="x2")
    plt.xlabel("t [s]")
    plt.ylabel("displacement")
    plt.grid()
    plt.legend()

    plt.figure()
    plt.plot(t, k2_t, label="k2(t)")
    plt.xlabel("t [s]")
    plt.ylabel("k2")
    plt.grid()
    plt.legend()

    plt.show()
